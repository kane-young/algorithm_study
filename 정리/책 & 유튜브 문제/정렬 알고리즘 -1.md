## 기준에 따라 데이터를 정렬

`정렬 `이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다.

프로그래밍할 때 데이터를 오름차순, 내림차순으로 정렬하는 경우가 많다. 정렬 알고리즘을 통해서 정렬을 하고 나면, 또 빠르게 탐색을 하는 `이진 탐색`을 사용할 수 있다.



### 선택 정렬

가장 원시적이고 단순한 정렬 알고리즘으로 배열을 처음부터 끝까지 탐색하면서 제일 작은 수를 제일 앞으로 이동, 그 다음 부터 맨 뒤까지 계속해서 탐색하여 제일 작은 수를 앞으로 배치하는 것이다.



**선택정렬의 시간 복잡도**

선택정렬의 경우 N-1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 된다. 또한 매번 가장 작은 수를 찾기 위해서 비교 연산을 해야된다. 총 연산 횟수는 `N + (N-1) + (N-2) + (N-3) + ... + 2` 로 볼 수 있다. 그래서 빅오로 표기하면 `O(n^2)` 상당히 큰 작업이다.



알고리즘 문제에서는 사용하기 힘든 정렬 방법인 것 같다.



### 삽입 정렬

`선택정렬` 과는 다르게 한 번 탐색할 때마다 해당 수를 적절한 위치에 삽입해준 다면 빠르지 않을까?

배열에서 2번째 요소부터 시작하여서 첫번째 요소와 비교하였을 때 크다? 그럼 오른쪽, 작다? 그럼 왼쪽, 3번째 요소의 경우도 첫번째 요소와 2번째 요소와 크기 비교를 하여서 적절한 위치를 찾는 것



소스 코드로 나타내면 아래와 같다

```swift
import Foundation

var array = [7,5,9,0,3,1,6,2,4,8]

func insertionSort(_ input: [Int]) -> [Int] {
    guard input.count > 1 else {
        return input
    }
    
    var list = input
    for i in 1..<list.count {
        let x = list[i]
        var j = i
        
        while j > 0 && list[j-1] > x {
            list[j] = list[j-1]
            j -= 1
        }
        list[j] = x
    }
    return list
}

array = insertionSort(array)
print(array)
```



n개의 요소들을 하나하나씩 1...n-1개와 비교를 해야되므로 `O(N^2)` 의 시간 복잡도를 가진다





### 퀵 정렬

정렬 알고리즘 중에서 가장 많이 사용되는 알고리즘이다. 이 책에서 다루지는 않지만 퀵 정렬과 비교할 만큼 빠른 알고리즘으로 `병합 정렬` 알고리즘이 있다. 대부분의 프로그래밍 언어의 표준 라이브러리에서 이 두 알고리즘을 사용한다.



"기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까?"



퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.

퀵 정렬에서는 `피벗(Pivot)` 이 사용된다. 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 "기준"을 바로 피벗이라고 표현한다. 



**step1**

리스트의 첫 번째 데이터를 피벗으로 설정한다. 이후 왼쪽에서 부터 5보다 큰 데이터를 선택하고, 오른쪽에서부터는 5보다 작은 데이터를 선택한다. 그리고 이제 두 숫자의 위치를 서로 변경한다.

**step2**

그 다음 다시 피벗보다 큰 데이터와 작은 데이터를 각각 찾는다. 계속해서 변경하고 두 index가 마주칠 때까지 계속한다.

**step3**

마주치게 될 경우에는 작은 데이터와 피벗의 위치를 서로 변경한다.

**step4**

분할 완료, 이제 왼쪽은 피벗보다 작은 수들로, 오른쪽은 피벗보다 큰 수들로 채워졌다.

**step5**

이러한 상태에서 왼쪽 리스트와 오른쪽 리스트를 개별적으로 정렬시키면 된다



퀵 정렬에서는 이처럼 특정한 리스트에서 피벗을 설정하여 정렬을 수행한 이후에, 피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트에서 다시 정렬을 수행한다. `재귀함수`와 동작 원리가 같다.

재귀함수에서는 종료 조건이 굉장히 중요하다. 그럼 종료 조건은?? 남은 리스트의 데이터 개수가 1개이면 된다.

```swift
let sampleArray = [5,7,9,0,3,1,6,2,4,8]

func quickSort(_ array: [Int]) -> [Int] {
  if array.count < 2 {
    return array
  } else {
    let pivot = array[0]
    let less = array.filter { $0 < pivot }
    let grater = array.filter { $0 > pivot }
    return quickSort(array: less) + [pivot] + quickSort(array: greator)
  }
}
```



위 방법은 분할 정복 전략을 사용하면서, 재귀함수를 활용한 퀵 정렬 소스 코드이다



**퀵 정렬의 시간 복잡도**

앞서 다룬 삽입정렬과 선택정렬의 경우는 `O(N^2)` 의 시간 복잡도를 가져 매우 비효율적이였다.

but, 퀵 정렬의 평균 시간 복잡도는 `O(NlogN)`이다. 앞서 말한 두 알고리즘에 비해서는 굉장히 효율적이다

하지만 최악의 경우 시간 복잡도가 `O(N^2)`를 가진다는 점도 기억해놓자...  





### 계수 정렬

`계수 정렬(Count Sort)` 알고리즘은 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다. 모든 데이터가 양의 정수인 상황을 가정해보자. 데이터의 개수가 N, 데이터 중 최댓값이 K일때, 계수 정렬은 최악의 경우에도 수행 시간 `O(N+K)`를 보장한다. 계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있다.

예를 들어 0이상 100이하인 성적 데이터를 정렬할 때 계수 정렬이 효과적이다. 다만, 가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크다면 계수 정렬은 사용할 수 없다. 계수 정렬이 이러한 특징을 가지는 이유는, 계수 정렬을 이용할 때는 모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언해야 하기 때문이다.



계수 정렬은 앞서 다뤘던 정렬 알고리즘처럼 데이터의 값을 비교한 뒤에 위치를 변경하며 정렬하는 방식이 아니다.



```swift
import Foundation

let array: [Int] = [7,5,9,0,3,1,6,2,9,1,4,8,0,5,2]
//모든 원소의 값이 0보다 크거나 같다고 가정

//모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
var count: [Int] = Array(repeating: 0, count: array.max()!+1)

for number in array {
    //각 데이터에 해당하는 인덱스의 값 증가
    count[number] += 1
}

//리스트에 기록된 정렬 정보를 확인
//등장한 횟수만큼 인덱스를 출력해보자!!
for i in 0..<count.count {
    for _ in 0..<count[i] {
        print(i, terminator: " ")
    }
}
```



계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다. 예를들어서, 데이터가 0과 999,999 두개만 있다고 가정을 해보자. 데이터는 단 두개지만 해당 정렬을 위해서 필요한 리스트의 크기는 100만개가 필요하다





### Swift의 정렬 라이브러리

자주 사용하는 표준 라이브러리의 Array `sort` 함수 같은 경우 시간 복잡도 `O(NlogN)` 을 보장한다.



### 정렬 라이브러리의 시간 복잡도

정렬 라이브러리는 항상 최악의 경우에도 시간 복잡도 `O(NlogN)`을 보장한다. Apple 에서 기본으로 제공하는 함수이다보니 성능이 워낙 좋을 것으로 보인다.



하지만 무조건적으로 기본 정렬 라이브러리를 사용해서는 안된다

1. **정렬 라이브러리로 풀 수 있는 문제**

단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 않게 풀 수 있다.

2. **정렬 알고리즘의 원리에 대해서 물어보는 문제**

선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.

3. **더 빠른 정렬이 필요한 문제**

퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 요구하는 기존의 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.
