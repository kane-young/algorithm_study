## 📌 자료구조 정리!! (큐!) Queue


### Swift에서 Queue 표현 1

~~~
import Foundation

public struct Queue<T>{
    fileprivate var array = [T]()
    
    public var isEmpty: Bool{
        return array.isEmpty
    }
    
    public var count: Int{
        return array.count
    }
    
    public mutating func enqueue(_ element: T){
        array.append(element)
    }
    
    public mutating func dequeue() -> T?{
        if isEmpty{
            return nil
        }else {
            return array.removeFirst()
        }
    }
    
    public var front: T?{
        return array.first
    }
}
~~~

다음의 표현들은 잘 작동하지만, 최적의 표현은 아니다

일단 Enqueuing 과정은 항상 O(1)의 시간 복잡도를 가진다.

하지만, dequeueing의 경우는 다르다. Dequeueing은 O(n)의 사간복잡도를 가진다.

```
before   [ "Ada", "Steve", "Tim", "Grace", xxx, xxx ]
                   /       /      /
                  /       /      /
                 /       /      /
                /       /      /
 after   [ "Steve", "Tim", "Grace", xxx, xxx, xxx ]
 ```

 맨 앞의 element가 삭제되고 전부 한칸씩 재정렬하기 때문이다.


<br>

 ### A more efficient queue
 <hr>


dequeueing을 효율적으로 만들기 위해서, 우리는 여유 공간을 만들 수 있다. 하지만, Array의 맨 앞에 있기 때문에 내장된 Swift 함수가 없어, 우리가 직접 정의해주어야 한다.

[ "Ada", "Steve", "Tim", "Grace", xxx, xxx ]

=> [ xxx, "Steve", "Tim", "Grace", xxx, xxx ]


주요 아이디어는 항목의 대기열을 해체할 때마다 배열의 내용을 전면으로 이동시키지 않고, 배열에서 항목의 위치를 비어 있음으로 표시한다는 것이다.

그리고 나머지 요소를 앞쪽으로 주기적으로 trimming 해주면 된다.

그래서 이렇게 움직이는 것은 O(n)의 시간 복잡도를 가지지만, 가끔 행해지기 때문에 평균적으로 O(1)의 시간복잡도를 가진다.

~~~
