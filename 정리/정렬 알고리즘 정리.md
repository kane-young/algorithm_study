## 동빈나 유튜브에서 본 예제 문제

### 정렬 알고리즘 정리
- 정렬이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것을 말한다.
- 일반적으로 문제 상황에 따라 적절한 정렬 알고리즘이 공식처럼 사용된다.
ex) 데이터의 개수가 많을때, 거의 다 정렬되어 있을 때 등등

#### 1. 선택 정렬 알고리즘
처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꿔주는 로직을 계속해서 반복한다.

맨 앞의 데이터는 n번 맨 뒤의 데이터는 2번 이므로 등차수열 형태의 시간 복잡도가 형성된다.
빅오표기법에 따르면 O(N 제곱) 형태가 나온다.

~~~
var array = [7,5,9,0,3,1,6,2,4,8]

for i in 0..<array.count-1{
    var minIndex = i
    for j in i+1..<array.count{
        if array[minIndex] > array[j]{
            minIndex = j
        }
    }
    
    let temp = array[i]
    array[i] = array[minIndex]
    array[minIndex] = temp
    
}


print(array)
//[0,1,2,3,4,5,6,7,8,9]
~~~

#### 2. 삽입 정렬 알고리즘
- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입합니다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작합니다.

2번째 항부터 시작해서 자신 보다 앞쪽에 있는 항들은 이미 정렬되어 있다는 전제하에 자신이 어디에 들어가면 좋을지를 찾아서 정렬하는 알고리즘이다.

```
var array = [7,5,9,0,3,1,6,2,4,8]

for i in 1..<array.count{
    for j in (1...i).reversed(){ //인덱스 i부터 1까지 1씩 감소하며 반복하는 문법
        if array[j] < array[j-1]{ //한칸씩 왼쪽으로 이동
            array.swapAt(j, j-1)
        } else{//자기보다 작은 데이터를 만나면 그 위치에서 멈춤
            break
        }
    }
}

print(array)

```

- 삽입정렬의 시간 복잡도는 역시 이중 for문의 사용으로 O(N 제곱)이다.
- 삽입 정렬의 경우 데이터가 거의 정렬되어 있는 경우 매우 빠르게 정렬된다.
최선의 경우에는 거의 O(N)의 시간 복잡도를 가진다


이미 정렬되어 있는 상태에서 다시 삽입 정렬을 수행하면 어떻게 될까?
-> O(N) 이 된다.

#### 3. 퀵 정렬 알고리즘
- 기준 데이터를 설정한 다음, 그 기준보다 큰 데이터와 작은 데이터 위치를 바꾸는 방법이다.
- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나이다.
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘이다.
- 가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(Pivot)로 설정한다.

퀵 정렬은 평균적으로는 O(NLogN)의 시간 복잡도를 가진다.
하지만 최악으로는 O(N 제곱)의 시간 복잡도를 가진다.
-> 표준 라이브러리를 이용하면 퀵 정렬을 대부분 표준 라이브러리에서 사용하기 때문에 O(NLogN)을 보장한다는 것을 알아야 한다.

~~~
var array = [7,5,9,0,3,1,6,2,4,8]

func quick_sort(start: Int, end: Int){
    if start >= end{//원소가 한개인 경우
        return
    }
    
    let pivot = start //피벗은 첫 번째 원소이다.
    
    var left = start + 1
    var right = end
    
    while(left <= right){
        while(left <= end && array[left] <= array[pivot]){
            left += 1
        }
        
        while right > start && array[right] >= array[pivot]{
            right -= 1
        }
        
        if left > right{
            array.swapAt(pivot, right)
        } else{
            array.swapAt(left, right)
        }
    }
    
    quick_sort(start: start, end: right - 1)
    quick_sort(start: right + 1, end: end)
}

quick_sort(start: 0, end: array.count - 1)
print(array)
~~~


#### 4. 계수 정렬
- 특정한 조건이 부합할 때만 사용할 수 있지만, 매우 빠르게 동작하는 정렬 알고리즘이다.
    - 계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현될 수 있을 때 사용가능합니다.
- 데이터의 개수가 N, 데이터(양수) 중 최댓값이 K일때 최악의 경우에도 수행 시간 O(N+K)를 보장합니다.

~~~
let array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

var countArray = Array(repeating: 0, count: 10)
//array 안의 모든 데이터를 index에 포함하는 list를 생성

for i in 0..<array.count{
    countArray[array[i]] += 1
}

for i in 0..<countArray.count{
    let num = countArray[i]
    for _ in 0..<num {
        print(i, terminator: "")
    }
}
//001122345567899
~~~

- 계수 정렬의 시간 복잡도와 공간 복잡도는 모두 O(N+K)이다.
- 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수도 있다.
    - 데이터가 0과 999,999로 단 2개만 존재하는 경우를 생각해보면 나머지 사이의 숫자에 대한 리스트들의 메모리와 계산 시간이 낭비된다.
    => 데이터의 범위가 넓을 때에는 계수 정렬의 활용이 어렵다

- 계수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용할 수 있습니다
    - 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수 정렬이 효과적입니다.



<hr>


### 마지막 정렬 알고리즘 비교하기

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징 |
|:----------|:----------:|----------:|:----------:|
| 선택 정렬 | O(N 제곱) | O(N) | 아이디어가 매우 간단합니다. |
| 삽입 정렬 | O(N 제곱) | O(N) | 데이터가 거의 정렬되어 있을 때는 가장 빠릅니다.|
| 퀵 정렬 | O(NlogN) | O(N) | 대부분의 경우에 가장 적합하며, 충분히 빠릅니다. |
| 계수 정렬 | O(N+K) | O(N + K) | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만, 매우 빠르게 동작한다. |